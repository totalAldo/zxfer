# TODO – Security Review

- [ ] `src/zxfer_globals.sh:118-138` – zxfer resolves `awk`, `zfs`, `ssh`, `parallel`, and other critical helpers via `which` and inherits whatever `PATH` the caller exposes. When zxfer runs as root (common during replication), any untrusted directory prepended to `PATH` allows a local attacker to drop a trojan binary that gets executed before the real system tool. Sanitize the execution environment up front (e.g., reset `PATH` to trusted directories or resolve each binary via a constant absolute path) so privilege escalation via path hijacking is impossible.
- [ ] `src/zxfer_zfs_send_receive.sh:185-206` – The custom `-Z/ZXFER_COMPRESSION` command strings (`g_cmd_compress`/`g_cmd_decompress`) are spliced directly into the send/receive pipelines without any validation or structured argument handling, so whatever text comes from configs/environment executes as shell syntax on both the local and remote hosts. If zxfer pulls its CLI/options from a writable config file, a compromised user can inject arbitrary commands with the privileges zxfer runs under. Rework the compression plumbing to treat these commands as arrays (or whitelist binaries/flags) before piping them through ssh.
- [ ] `src/zxfer_globals.sh:738-835` – Property restores (`-e`) trust whichever `.zxfer_backup_info.*` file is found in `ZXFER_BACKUP_DIR` and only reject symlinks. There is no ownership or permission check before ingesting the file contents, even though those entries drive property changes like `mountpoint`, `sharenfs`, or encryption metadata. If the secure backup directory ever ends up group-writable (for example, mounted over shared storage), a less-privileged user can poison the metadata and coerce zxfer to reconfigure datasets on the next restore. Add explicit owner/permission verification before reading backup files and refuse to proceed when they are not root/0600.

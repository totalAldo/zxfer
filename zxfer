#!/bin/sh
# BSD HEADER START

# Copyright (c) 2013-2019 Allan Jude <allanjude@freebsd.org>
# Copyright (c) 2010,2011 Ivan Nash Dreckman
# Copyright (c) 2007, 2008 Constantin Gonzalez
# All rights reserved.

# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:

#     * Redistributions of source code must retain the above copyright notice,
#       this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above copyright notice,
#       this list of conditions and the following disclaimer in the documentation
#       and/or other materials provided with the distribution.

# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

# BSD HEADER END

#
# zxfer
#
# Transfer a source zfs filesystem, directory or files to a destination, using
# either zfs send/receive or rsync to do the heavy lifting.

# changes by Aldo Gonzalez
# 2024.03.11
# refactor inspect_delete_snap() into multiple functions with the primary goal
# of optimizing the snapshot deletion logic. Convert that from nested loops
# to using temp files and comm for a more efficient comparison.
#
# 2024.03.09
# - add -z option to use zstd compression
# - add -Z option to specify the zstd compression command
# - refactor of the code
#   . add execute_command() function
#   . add throw_error functions
#   . refactor copy_snap()
#   . rename option variables for readability
#   . wrap long blocks in functions to improve readability
#   . update verbose messages to display the command being executed
#   . group functions by mode
#

# Comments, suggestions, bug reports please to:
# Allan Jude  <allanjude a-t freebsd d-o-t org>
#

# Acknowledgments
# Thanks to Ivan Nash Dreckman for creating zxfer and writing good documentation
# which resulted in zxfer being the most useful of the available tools
#
# Thanks to Constantin Gonzalez (original author of zfs-replicate) for
# the generous permission and licensing of his script zfs-replicate which
# (version 0.7) was used as the basis for this script. Thanks in turn to
# those who contributed to his script.

# Also thanks very much to Constantin for his encouragement, support and
# collaboration along the way. His advice on various decision paths has been
# invaluable.

# Background
# This script is a merge of two scripts - one of my own using Constantin's
# as a template, and my extensively modified version of his zfs-replicate
# script.

# There were two different use cases that lead to both being developed. One
# was an extension of zfs-replicate - I wanted to be able to easily back up
# a whole storage pool to a HDD via an e-SATA dock, with one command. I
# wanted an exact replica of that pool, including snapshots and properties.

# The other use case was to backup a SSD based root mirror to a larger
# HDD based storage pool. It needed atomicity and it needed to be independent
# of snapshots, because I was keeping most of the snapshots on the HDD based
# pool. For this I used rsync.

# In both cases I wanted the reliability that comes with checking hashes
# and checksums against the original files to ensure that the correct
# information had been written, and AFAIK both tools to do this.

# Since then, the scripts have been merged, and the number of features has
# increased. I hope you find it useful.

# Known bugs/gotchas:
# 2024.03.09
# - The -D option does not work as expected when creating a dataset on the target
#
# (This is a bug of ZFS on FreeBSD and not this script.)
# There are several properties in FreeBSD that when set via "zfs create"
# or "zfs set" will have the source stay as default while others are
# set to local. This does not have any real impacts because these properties
# are not inheritable. See definition for $fbsd_readonly_properties.
#
#     zxfer [-dFnPsUv] [-k | -e] [-b | -B] {-N path/to/src | -R path/to/src}
#           [-z] [-Z "full zstd compression command"]
#           [-m [c FMRI|pattern[ FMRI|pattern]...]]] [-O user@host]
#           [-D 'progress dialog options'] [-I properties,to,ignore]
#           [-T user@host] [-o option1=value1,option2=value2...] [-g days]
#           destination
#     zxfer {-S} [-dilpPnv] [-k | -e] [-b | -B] [-f /path/to/rsfile]
#           {-R /path/to/src1,path/to/src2... | -N /path/to/src1,path/to/src2...}
#           [-o option1=value1,option2=value2...] [-E pattern] [-L value]
#           [-u snapshot] destination
#     zxfer [-h]
#
#           Where destination is a ZFS filesystem e.g.  poolname/fsname

###############################################################################
# GLOBALS
###############################################################################

init_globals() {
  # zxfer version
  zxfer_version="1.2.0-20240309"

  # Default values
  option_b_beep_always=0
  option_B_beep_on_success=0
  option_d_delete_destination_snapshots=0
  option_D_display_progress_bar=""
  option_e_restore_property_mode=0
  option_E_rsync_exclude_patterns=""
  option_f_rsync_file_options=""
  option_g_grandfather_protection=""
  option_i_rsync_include_zfs_mountpoints=0
  option_I_ignore_properties=""
  option_F_force_rollback=""
  option_k_backup_property_mode=0
  option_l_rsync_legacy_mountpoint=0
  option_L_rsync_levels_deep=""
  option_o_override_property=""
  option_O_origin_user_host=""
  option_p_rsync_persist=0
  option_P_transfer_property=0
  option_R_recursive=""
  option_m_migrate=0
  option_n_dryrun=0
  option_N_nonrecursive=""
  option_S_rsync_mode=0
  option_s_make_snapshot=0
  option_T_target_user_host=""
  option_u_rsync_use_existing_snapshot=0
  option_U_skip_unsupported_properties=0
  option_v_verbose=0
  option_z_compress=0

  services=""
  torestart=""

  source=""
  sourcefs=""
  destination=""
  backup_file_extension=".zxfer_backup_info"
  backup_file_contents=""

  # operating systems
  home_os=""
  source_os=""
  dest_os=""

  # as in the "cp" man page
  trailing_slash=0

  # default compression commands
  compress_cmd="zstd -3"
  decompress_cmd="zstd -d"

  lcat_cmd=""
  awk_cmd=$(which awk) # location of awk or gawk on home OS

  zfs_cmd=$(which zfs)
  ssh_cmd=$(which ssh)
  rsync_cmd=""

  # default zfs commands, can be overridden by -O or -T
  LZFS=$zfs_cmd
  RZFS=$zfs_cmd

  # specific to zfs mode
  zxfer_new_snapshot_name=zxfer_$$_$(date +%Y%m%d%H%M%S)

  current_date=$(date +%s) # current date in seconds from 1970

  # specific to rsync mode
  snapshot_name="zxfertempsnap"

  # used in rsync transfers, to turn off the backup file writing
  # the first time
  dont_write_backup=0

  ensure_writable=0 # when creating/setting properties, ensures readonly=off

  # default rsync options - see http://www.daemonforums.org/showthread.php?t=3948
  default_rsync_options="-clptgoD --inplace --relative -H --numeric-ids"

  # note that I am including in the "readonly properties list
  # 3 properties that are technically not readonly but we will
  # remove them from the override list as it does not make
  # sense to try and transfer them - version, volsize and mountpoint
  # Others have been added since. This is a potential refactor point
  # to split into two lists, $readonly_properties and $zxfer_unsupported_properties

  readonly_properties="type,creation,used,available,referenced,\
compressratio,mounted,version,primarycache,secondarycache,\
usedbysnapshots,usedbydataset,usedbychildren,usedbyrefreservation,\
version,volsize,mountpoint,mlslabel,keysource,keystatus,rekeydate,encryption,\
refcompressratio,written,logicalused,logicalreferenced,createtxg,guid,origin,\
filesystem_count,snapshot_count,clones,defer_destroy,receive_resume_token,\
userrefs,objsetid"

  # Properties not supported on FreeBSD
  fbsd_readonly_properties="aclmode,aclinherit,devices,nbmand,shareiscsi,vscan,\
xattr,dnodesize"

  # Properties not supported on Solaris Express 11
  solexp_readonly_properties="jailed,aclmode,shareiscsi"
}

###############################################################################
# COMMON FUNCTIONS
###############################################################################

#
# Add the debug_start() and debug_end() functions to enable/disable debugging
# between code blocks.
debug_start() {
  set -x
}

debug_end() {
  set +x
}

#
# Print out usage information
#
usage() {
  cat <<EOT
usage:
     zxfer [-dFnPsUv] [-k | -e] [-b | -B] {-N path/to/src | -R path/to/src}
           [-z] [-Z "full zstd compression command"]
           [-m [c FMRI|pattern[ FMRI|pattern]...]]] [-O user@host]
           [-D 'progress dialog options'] [-I properties,to,ignore]
           [-T user@host] [-o option1=value1,option2=value2...] [-g days]
           destination
     zxfer {-S} [-dilpPnv] [-k | -e] [-b | -B] [-f /path/to/rsfile]
           {-R /path/to/src1,path/to/src2... | -N /path/to/src1,path/to/src2...}
           [-o option1=value1,option2=value2...] [-E pattern] [-L value]
           [-u snapshot] destination
     zxfer [-h]

           Where destination is a ZFS filesystem e.g.  poolname/fsname

zxfer has a man page that explains each of the options in detail, along with
usage examples. To access the man page, type:
$ man zxfer

EOT
}

#
# Check command line parameters.
#
read_command_line_switches() {
  while getopts bBc:deE:f:Fg:hiI:klL:lmnN:o:O:pPPR:sST:u:Uv?:D:zZ: i; do
    case $i in
    b)
      option_b_beep_always=1
      ;;
    B)
      option_B_beep_on_success=1
      ;;
    c)
      services="$OPTARG"
      ;;
    d)
      option_d_delete_destination_snapshots=1
      ;;
    D)
      option_D_display_progress_bar="$OPTARG"
      ;;
    e)
      option_e_restore_property_mode=1
      # Need to transfer properties, just the backed up properties
      # are substituted
      option_P_transfer_property=1
      ;;
    E)
      option_E_rsync_exclude_patterns="--exclude=$OPTARG $option_E_rsync_exclude_patterns"
      ;;
    f)
      option_f_rsync_file_options="$OPTARG"
      ;;
    F)
      option_F_force_rollback="-F"
      ;;
    g)
      option_g_grandfather_protection="$OPTARG"
      ;;
    h)
      usage
      exit 2
      ;;
    i)
      option_i_rsync_include_zfs_mountpoints=1
      ;;
    I)
      option_I_ignore_properties="$OPTARG"
      ;;
    k)
      option_k_backup_property_mode=1
      # In order to back up the properties of the source, the
      # properties of the source must be transferred as well.
      option_P_transfer_property=1
      ;;
    l)
      option_l_rsync_legacy_mountpoint=1
      ;;
    L)
      option_L_rsync_levels_deep="$OPTARG"
      ;;
    m)
      option_m_migrate=1
      option_s_make_snapshot=1
      option_P_transfer_property=1
      ;;
    n)
      option_n_dryrun=1
      ;;
    N)
      option_N_nonrecursive="$OPTARG"
      ;;
    o)
      option_o_override_property="$OPTARG"
      ;;
    O)
      # since we are using the -O option, we are pulling a remote transfer
      # so we need to use the ssh command to execute the zfs commands
      # $OPTARG is the user@host
      LZFS="$ssh_cmd $OPTARG $zfs_cmd"
      option_O_origin_user_host="$OPTARG"
      ;;
    p)
      option_p_rsync_persist=1
      ;;
    P)
      option_P_transfer_property=1
      ;;
    R)
      option_R_recursive="$OPTARG"
      ;;
    s)
      option_s_make_snapshot=1
      ;;
    S)
      option_S_rsync_mode=1
      ;;
    T)
      # since we are using the -T option, we are pushing a remote transfer
      # so we need to use the ssh command to execute the zfs commands
      # $OPTARG is the user@host
      RZFS="$ssh_cmd $OPTARG $zfs_cmd"
      option_T_target_user_host="$OPTARG"
      ;;
    u)
      option_u_rsync_use_existing_snapshot=1
      snapshot_name="$OPTARG"
      ;;
    U)
      option_U_skip_unsupported_properties=1
      ;;
    v)
      option_v_verbose=1
      ;;
    z)
      # Pipes the send and receive commands through zstd
      option_z_compress=1
      ;;
    Z)
      # specify the zstd compression command, like "zstd -T0 -6"
      option_z_compress=1
      compress_cmd="$OPTARG"
      ;;
    \?)
      throw_usage_error "Invalid option provided." 2
      ;;
    esac
  done
}

#
# Beeps a success sound if -B enabled, and a failure sound if -b or -B enabled.
#
beep() {
  _exit_status=${1:-1} # default to 1 (failure)

  if [ $option_b_beep_always -eq 1 ] || [ $option_B_beep_on_success -eq 1 ]; then
    # load the speaker kernel module if not loaded already
    speaker_km_loaded=$(kldstat | grep -c speaker.ko)
    if [ "$speaker_km_loaded" = "0" ]; then
      kldload "speaker"
    fi

    # play the appropriate beep
    if [ "$_exit_status" -eq 0 ]; then
      if [ $option_B_beep_on_success -eq 1 ]; then
        echo "T255CCMLEG~EG..." >/dev/speaker # success sound
      fi
    else
      echo "T150A<C.." >/dev/speaker # failure sound
    fi
  fi
}

#
# Gets a $(uname), i.e. the operating system, for origin or target, if remote.
# Takes: $1=either $option_O_origin_user_host or $option_T_target_user_host
#
get_os() {
  _input_options=$1
  _output_os=""

  # Get uname of the destination (target) machine, local or remote
  if [ "$_input_options" = "" ]; then
    _output_os=$(uname)
  else
    _output_os=$($_input_options uname)
  fi

  echo "$_output_os"
}

#
# Initializes OS and local/remote specific variables
#
init_variables() {
  home_os=$(get_os "")

  # determine the source_os
  if [ "$option_O_origin_user_host" != "" ]; then
    source_os=$(get_os "$ssh_cmd $option_O_origin_user_host")
  else
    source_os=$(get_os "")
  fi

  # determine the dest_os
  if [ "$option_T_target_user_host" != "" ]; then
    dest_os=$(get_os "$ssh_cmd $option_T_target_user_host")
  else
    dest_os=$(get_os "")
  fi

  if [ $option_e_restore_property_mode -eq 1 ]; then
    lcat_cmd=$("$ssh_cmd" "$option_O_origin_user_host" which cat)
  fi

  if [ $option_S_rsync_mode -eq 1 ]; then
    rsync_cmd=$(which rsync)
  fi

  if [ "$home_os" = "SunOS" ]; then
    awk_cmd=$(which gawk)
  fi
}

#
# Checks that options make sense, etc.
#
consistency_check() {
  # disallow backup and restore of properties at same time
  if [ $option_k_backup_property_mode -eq 1 ] && [ $option_e_restore_property_mode -eq 1 ]; then
    throw_usage_error "You cannot bac(k)up and r(e)store properties at the same time."
  fi

  # disallow both beep modes, enforce using one or the other.
  if [ $option_b_beep_always -eq 1 ] && [ $option_B_beep_on_success -eq 1 ]; then
    throw_usage_error "You cannot use both beep modes at the same time."
  fi

  if [ $option_S_rsync_mode -eq 1 ]; then
    # rsync mode

    # check for incompatible options
    if [ "$option_F_force_rollback" = "-F" ]; then
      throw_usage_error "-F option cannot be used with -S (rsync mode)"
    fi

    if [ $option_s_make_snapshot -eq 1 ]; then
      throw_usage_error "-s option cannot be used with -S (rsync mode)"
    fi

    if [ "$option_O_origin_user_host" != "" ] || [ "$option_T_target_user_host" != "" ]; then
      throw_usage_error "-O or -T option cannot be used with -S (rsync mode)"
    fi

    if [ $option_m_migrate -eq 1 ]; then
      throw_usage_error "-m option cannot be used with -S (rsync mode)"
    fi
  else
    #zfs send mode

    # check for incompatible options
    if [ "$option_f_rsync_file_options" != "" ]; then
      throw_usage_error "-f option can only be used with -S (rsync mode)"
    fi

    if [ "$option_L_rsync_levels_deep" != "" ]; then
      throw_usage_error "-L option can only be used with -S (rsync mode)"
    fi

    if [ $option_z_compress -eq 1 ] &&
      [ "$option_O_origin_user_host" = "" ] &&
      [ "$option_T_target_user_host" = "" ]; then
      throw_usage_error "-z option can only be used with -O or -T option"
    fi

    # disallow migration related options and remote transfers at same time
    if [ "$option_T_target_user_host" != "" ] || [ "$option_O_origin_user_host" != "" ]; then
      if [ $option_m_migrate -eq 1 ] || [ "$services" != "" ]; then
        throw_usage_error "You cannot migrate to or from a remote host."
      fi
    fi
  fi
}

# Function to handle errors
throw_error() {
  _msg=$1
  _exit_status=${2:-1} # global used by beep
  echo "$_msg"
  beep "$_exit_status"
  exit "$_exit_status"
}

throw_usage_error() {
  _msg=$1
  _exit_status=${2:-1} # global used by beep
  echo "Error: $_msg"
  usage
  beep "$_exit_status"
  exit "$_exit_status"
}

# sample usage:
# execute_command "ls -l" 1
execute_command() {
  _cmd=$1
  _is_continue_on_fail=${2:-0}

  if [ $option_n_dryrun -eq 1 ]; then
    echov "Dry run: $_cmd"
    return
  fi

  echov "$_cmd"
  if [ "$_is_continue_on_fail" -eq 1 ]; then
    eval "$_cmd" || {
      echo "Non-critical error when executing command. Continuing."
    }
  else
    eval "$_cmd" || throw_error "Error when executing command."
  fi
}

#
# Print out information if in verbose mode
#
echov() {
  if [ $option_v_verbose -eq 1 ]; then
    echo "$@"
  fi
}

#
# Gets the backup properties from a previous backup of those properties
# This takes $initial_source. The backup file is usually in directory
# corresponding to the parent filesystem of $initial_source
#
get_backup_properties() {
  # We will step back through the filesystem hierarchy from $initial_source
  # until the pool level, looking for the backup file, stopping when we find
  # it or terminating with an error.
  _suspect_fs=$initial_source
  _suspect_fs_tail=""
  _found_backup_file=0
  while [ $_found_backup_file -eq 0 ]; do
    _backup_file_dir=$($LZFS get -H -o value mountpoint "$_suspect_fs")

    if $option_O_origin_user_host [ -r "$_backup_file_dir/$backup_file_extension.$_suspect_fs_tail" ]; then
      restored_backup_file_contents=$($option_O_origin_user_host "$lcat_cmd" "$_backup_file_dir/$backup_file_extension.$_suspect_fs_tail")
      _found_backup_file=1
    else
      _suspect_fs_parent=$(echo "$_suspect_fs" | sed -e 's%/[^/]*$%%g')
      if [ "$_suspect_fs_parent" = "$_suspect_fs" ]; then
        echo "Error: Cannot find backup property file. Ensure that it"
        echo "exists and that it is in a directory corresponding to the"
        echo "mountpoints of one of the ancestor filesystems of the source."
        usage
        exit 1
      else
        _suspect_fs_tail=$(echo "$_suspect_fs" | sed -e 's/.*\///g')
        _suspect_fs=$_suspect_fs_parent
      fi
    fi
  done

  # at this point the $backup_file_contents will be a list of lines with
  # $source,$actual_dest,$source_pvs
}

#
# Writes the backup properties to a file that is in the directory
# corresponding to the destination filesystem
#
write_backup_properties() {
  _is_tail=$(echo "$initial_source" | sed -e 's/.*\///g')
  _backup_file_dir=$($RZFS get -H -o value mountpoint "$destination")
  echov "Writing backup info to location $_backup_file_dir/$backup_file_extension.$_is_tail"

  # Construct the backup file contents
  _backup_file_header="#zxfer property backup file;#version:$zxfer_version;#R options:$option_R_recursive;#N options:$option_N_nonrecursive;#destination:$destination;#initial_source:$_is_tail;#option_S_rsync_mode:$option_S_rsync_mode;"
  _backup_date=$(date)
  backup_file_contents="$_backup_file_header#backup_date:$_backup_date$backup_file_contents"

  # Construct the command to write the backup file
  backup_file_cmd="echo \"$backup_file_contents\" | tr \";\" \"\n\" > $_backup_file_dir/$backup_file_extension.$_is_tail"

  # Execute the command
  if [ $option_n_dryrun -eq 0 ]; then
    echo "$backup_file_cmd" | "$ssh_cmd $option_T_target_user_host" sh ||
      throw_error "Error writing backup file. Is filesystem mounted?"
  else
    echo "echo \"$backup_file_cmd\" | \"$ssh_cmd $option_T_target_user_host\" sh"
  fi
}

#
# Strips the sources from a list of properties=values=sources,
# e.g. output is properties=values,
# output is in $new_rmvs_pv
#
remove_sources() {
  new_rmvs_pv="" # global

  _rmvs_list=$1

  for rmvs_line in $_rmvs_list; do
    rmvs_property=$(echo "$rmvs_line" | cut -f1 -d=)
    rmvs_value=$(echo "$rmvs_line" | cut -f2 -d=)
    new_rmvs_pv="$new_rmvs_pv$rmvs_property=$rmvs_value,"
  done

  # remove trailing comma
  new_rmvs_pv=${new_rmvs_pv%,}
}

#
# Selects only the specified properties
# and values in the format property1=value1=source,...
# Used to select the "must create" properties
#
select_mc() {
  new_mc_pvs="" # global

  _mc_list=$1          # target list of properties, values
  _mc_property_list=$2 # list of properties to select

  # remove readonly properties from the override list
  for mc_line in $_mc_list; do
    found_mc=0
    mc_property=$(echo "$mc_line" | cut -f1 -d=)
    mc_value=$(echo "$mc_line" | cut -f2 -d=)
    mc_source=$(echo "$mc_line" | cut -f3 -d=)
    # test for readonly properties
    for property in $_mc_property_list; do
      if [ "$property" = "$mc_property" ]; then
        found_mc=1
        #since the property was matched let's not waste time looking for it again
        _mc_property_list=$(echo "$_mc_property_list" | tr -s "," "\n" |
          grep -v ^"$property"$ | tr -s "\n" ",")
        break
      fi
    done
    if [ $found_mc -eq 1 ]; then
      new_mc_pvs="$new_mc_pvs$mc_property=$mc_value=$mc_source,"
    fi
  done

  new_mc_pvs=${new_mc_pvs%,}
}

#
# Removes the readonly properties and values from a list of properties
# values and sources in the format property1=value1=source1,...
# output is in new_rmv_pvs
#
remove_properties() {
  new_rmv_pvs="" # global

  _rmv_list=$1    # the list of properties=values=sources,...
  _remove_list=$2 # list of properties to remove

  for rmv_line in $_rmv_list; do
    found_readonly=0
    rmv_property=$(echo "$rmv_line" | cut -f1 -d=)
    rmv_value=$(echo "$rmv_line" | cut -f2 -d=)
    rmv_source=$(echo "$rmv_line" | cut -f3 -d=)
    # test for readonly properties
    for property in $_remove_list; do
      if [ "$property" = "$rmv_property" ]; then
        if [ "$rmv_source" = "override" ]; then
          # The user has specifically required we set this property
          continue
        fi
        found_readonly=1
        #since the property was matched let's not waste time looking for it again
        _remove_list=$(echo "$_remove_list" | tr -s "," "\n" | grep -v ^"$property"$)
        _remove_list=$(echo "$_remove_list" | tr -s "\n" ",")
        break
      fi
    done
    if [ $found_readonly -eq 0 ]; then
      new_rmv_pvs="$new_rmv_pvs$rmv_property=$rmv_value=$rmv_source,"
    fi
  done

  new_rmv_pvs=${new_rmv_pvs%,}
}

#
# Removes the readonly properties and values from a list of properties
# values and sources in the format property1=value1=source1,...
# output is in new_rmv_pvs
#
remove_unsupported_properties() {
  _orig_set_list=$1 # the list of properties=values=sources,...
  _FUNCIFS=$IFS
  IFS=","

  only_supported_properties=""
  for orig_line in $_orig_set_list; do
    found_unsup=0
    orig_set_property=$(echo "$orig_line" | cut -f1 -d=)
    orig_set_value=$(echo "$orig_line" | cut -f2 -d=)
    orig_set_source=$(echo "$orig_line" | cut -f3 -d=)
    for property in $unsupported_properties; do
      if [ "$property" = "$orig_set_property" ]; then
        found_unsup=1
        break
      fi
    done
    if [ $found_unsup -eq 0 ]; then
      only_supported_properties="$only_supported_properties$orig_set_property=$orig_set_value=$orig_set_source,"
    else
      echov "Destination does not support property ${orig_set_property}=${orig_set_value}"
    fi
  done
  only_supported_properties=${only_supported_properties%,}
  IFS=$_FUNCIFS
}

#
# Normalize the list of properties to set by using a mix of human-readable and
# machine-readable values
#
resolve_human_vars() {
  _machine_vars=$1
  _human_vars=$2
  _FUNCIFS=$IFS
  IFS=","

  human_results=
  for h_var in $_human_vars; do
    h_prop=${h_var%%=*}
    for m_var in $_machine_vars; do
      m_prop=${m_var%%=*}
      if [ "$h_prop" = "$m_prop" ]; then
        machine_property=$(echo "$m_var" | cut -f1 -d=)
        machine_value=$(echo "$m_var" | cut -f2 -d=)
        machine_source=$(echo "$m_var" | cut -f3 -d=)
        human_value=$(echo "$h_var" | cut -f2 -d=)
        if [ "$human_value" = "none" ]; then
          machine_value=$human_value
        fi
        human_results="${human_results}$machine_property=$machine_value=$machine_source,"
      fi
    done
  done
  human_results=${human_results%,}
  IFS=$_FUNCIFS
}

#
# Prepare the actual destination (actual_dest) as used in zfs receive.
# Uses $trailing_slash, $source, $part_of_source_to_delete, $destination,
# $initial_source, $trailing_slash_dest_tail
# Output is $actual_dest
#
get_actual_dest() {
  # A trailing slash means that the root filesystem is transferred straight
  # into the dest fs, no trailing slash means that this fs is created
  # inside the destination.
  if [ "$trailing_slash" -eq 0 ]; then
    # If the original source was backup/test/zroot and we are transferring
    # backup/test/zroot/tmp/foo, $dest_tail is zroot/tmp/foo
    dest_tail=$(echo "$source" | sed -e "s%^$part_of_source_to_delete%%g")
    actual_dest="$destination"/"$dest_tail"
  else
    trailing_slash_dest_tail=$(echo "$source" | sed -e "s%^$initial_source%%g")
    actual_dest="$destination$trailing_slash_dest_tail"
  fi
}

#
# Transfers properties from any source to destination.
# Either creates the filesystem if it doesn't exist,
# or sets it after the fact.
# Also, checks to see if the override properties given as options are valid.
# Needs: $source, $initial_source, $actual_dest, $recursive_dest_list
# $dont_write_backup
# $ensure_writable
#
transfer_properties() {
  # We have chosen to set all source properties in the case of -P
  # Any -o values will be set too, and will override any values from -P.
  # Where the destination does not exist, it will be created.

  # Get the list of properties to enforce on the destination. This will be an
  # amalgam of -o options, and if -P exists, a list of the source properties.

  # get source properties,values,sources in form
  # property1=value1=source1,property2=value2=source2,...
  # Use -p to remove units, since localization can make these incompatible
  source_pvs=$($LZFS get -Hpo property,value,source all "$source" |
    tr "\t" "=" | tr "\n" ",")
  source_pvs=${source_pvs%,}
  source_human_pvs=$($LZFS get -Ho property,value,source all "$source" |
    tr "\t" "=" | tr "\n" ",")
  source_human_pvs=${source_human_pvs%,}

  # Check if the source is a zvol, which requires some special handling
  source_dstype=$($LZFS get -Hpo value type "$source")
  source_volsize=$($LZFS get -Hpo value volsize "$source")

  # Some localizations (German, French) use a comma as a decimal separator which
  # changes the interpretation of the value on machines with a different
  # localization.  Some OSes (OS X) use odd units (Ki) instead of K, and the
  # values cannot be interpretted properly on other localizations
  # Resolve this issue by passing -p which generates 'script parsable' output
  # However, some properties have a value of 'none', that in -p ends up having
  # a different value (filesystem_count=18446744073709551615)
  # clean these up by comparing the two outputs and making the right decision
  resolve_human_vars "$source_pvs" "$source_human_pvs"
  source_pvs="$human_results"

  # add to the details to allow backup of properties
  # unless $dont_write_backup non-zero, as with first rsync transfer
  # of properties
  if [ $option_k_backup_property_mode -eq 1 ] && [ $dont_write_backup -eq 0 ]; then
    backup_file_contents="$backup_file_contents;\
$source,$actual_dest,$source_pvs"
  fi

  # If we are restoring properties, then get source_pvs from the backup file
  if [ $option_e_restore_property_mode -eq 1 ]; then
    source_pvs=$(echo "$restored_backup_file_contents" | grep "^[^,]*,$source," |
      sed -e 's/^[^,]*,[^,]*,//g')
    if [ "$source_pvs" = "" ]; then
      throw_usage_error "Can't find the properties for the filesystem $source"
    fi
  fi

  # Just using option_o_override_property_pv so that we can modify it
  option_o_override_property_pv=$option_o_override_property

  # Now to ensure writable, if that is set.
  if [ $ensure_writable -eq 1 ]; then
    # make sure that the option_o_override_property_pv includes only readonly=off
    option_o_override_property_pv=$(echo "$option_o_override_property_pv" | sed -e 's/readonly=on/readonly=off/g')

    # make sure that the source_pvs includes only readonly=off
    source_pvs=$(echo "$source_pvs" | sed -e 's/readonly=on/readonly=off/g')
  fi

  valid_option_property=0
  #change the field separator to a ","
  OLDIFS=$IFS
  IFS=","

  # Test to see if each -o property is valid; leave value testing to zfs.
  # Note that this only needs to be done once and this is a good place.
  if [ "$initial_source" = "$source" ]; then
    for op_line in $option_o_override_property_pv; do
      op_property=$(echo "$op_line" | cut -f1 -d=)
      for sp_line in $source_pvs; do
        sp_property=$(echo "$sp_line" | cut -f1 -d=)
        if [ "$op_property" = "$sp_property" ]; then
          valid_option_property=1
          break # break out of the loop, we found what we wanted
        fi
      done
      if [ $valid_option_property -eq 0 ]; then
        throw_usage_error "Invalid option property - check -o list for syntax errors."
      else
        valid_option_property=0
      fi
    done
  fi

  # Create the override_pvs list and creation_pvs list.
  # creation_pvs will be used in the instance where we need to create the
  # destination. override_pvs will be used in the instance where we need
  # to set/inherit destination properties.
  override_pvs=""
  creation_pvs=""
  # note that if this function is executed, either option P or o must
  # have been invoked
  if [ $option_P_transfer_property -eq 0 ]; then # i.e. option o contains something
    for op_line in $option_o_override_property_pv; do
      op_property=$(echo "$op_line" | cut -f1 -d=)
      op_value=$(echo "$op_line" | cut -f2 -d=)
      override_source="override"
      override_pvs="$override_pvs$override_property=\
$override_value=$override_source,"
    done
  else
    # Get a list of properties and values to override the destination's.
    # Note that the overrides need to be removed from the creation list as
    # they will be auto-inherited from the initial source. Note also that
    # only "local" options need to be specified in the creation list, as
    # all others will be auto-inherited.
    #
    for sp_line in $source_pvs; do
      override_property=$(echo "$sp_line" | cut -f1 -d=)
      override_value=$(echo "$sp_line" | cut -f2 -d=)
      override_source=$(echo "$sp_line" | cut -f3 -d=)
      creation_property=$override_property
      creation_value=$override_value
      creation_source=$override_source
      for op_line in $option_o_override_property_pv; do
        op_property=$(echo "$op_line" | cut -f1 -d=)
        op_value=$(echo "$op_line" | cut -f2 -d=)
        if [ "$op_property" = "$override_property" ]; then
          override_property=$op_property
          override_value=$op_value
          override_source="override"
          creation_property="NULL"
          break # break out of the loop, we found what we wanted
        fi
      done
      override_pvs="$override_pvs$override_property=$override_value=$override_source,"
      if [ "$creation_property" != "NULL" ] && [ "$creation_source" = "local" ]; then
        creation_pvs="$creation_pvs$creation_property=$creation_value=$creation_source,"
      elif [ "$source_dstype" = "volume" ] && [ "$creation_property" = "refreservation" ]; then
        creation_pvs="$creation_pvs$creation_property=$creation_value=$creation_source,"
      fi
    done
  fi

  # Remove several properties not supported on FreeBSD.
  if [ "$dest_os" = "FreeBSD" ]; then
    readonly_properties="$readonly_properties,$fbsd_readonly_properties"
  fi

  # Remove several properties not supported on Solaris Express.
  if [ "$dest_os" = "SunOS" ] && [ "$source_os" = "FreeBSD" ]; then
    readonly_properties="$readonly_properties,$solexp_readonly_properties"
  fi

  # Remove the readonly properties and values.
  remove_properties "$override_pvs" "$readonly_properties"
  # Remove the properties the user has asked us to ignore
  if [ -n "$option_I_ignore_properties" ]; then
    remove_properties "$new_rmv_pvs" "$option_I_ignore_properties"
  fi
  override_pvs="$new_rmv_pvs"

  # Remove any properties that are not supported by the destination
  if [ -n "$unsupported_properties" ]; then
    remove_unsupported_properties "$override_pvs"
    override_pvs="$only_supported_properties"
  fi

  dest_exist=$(echo "$recursive_dest_list" | grep -c "^$actual_dest$")

  # This is where we actually create or modify the destination filesystem.
  # Is the destination absent? If so, just create with correct option list.
  if [ "$dest_exist" = "0" ]; then
    if [ "$initial_source" = "$source" ]; then
      # as this is the initial source, we want to transfer all properties from
      # the source, overridden with option_o_override_property values as necessary
      remove_sources "$override_pvs"
      override_option_list=$(echo "$new_rmvs_pv" | tr "," "\n" | sed "s/\(.*\)=\(.*\)/\1=\'\2\'/g" | tr "\n" "," | sed 's/,$//' | sed -e 's/,/ -o /g')
      if [ "$override_option_list" != "" ]; then
        override_option_list=" -o $override_option_list"
      fi
      if [ "$source_dstype" = "volume" ]; then
        override_option_list=" -V $source_volsize $override_option_list"
      fi

      # If not, create it with the override list and be done with it -
      # we have now transferred all properties
      echov "Creating destination filesystem \"$actual_dest\" \
with specified properties."

      # revert to old field separator
      # (This and reversion back is so that $RZFS command works with -r)
      IFS=$OLDIFS

      if [ $option_n_dryrun -eq 0 ]; then
        eval "$RZFS create $override_option_list $actual_dest" ||
          throw_error "Error when creating destination filesystem."
      else
        echo "$RZFS create $override_option_list $actual_dest"
      fi

      #change the field separator to a ","
      OLDIFS=$IFS
      IFS=","

    else
      # for non-initial source, all the overrides will be inherited, hence
      # create with creation_pvs list
      remove_properties "$creation_pvs" "$readonly_properties"
      # Remove the properties the user has asked us to ignore
      if [ -n "$option_I_ignore_properties" ]; then
        remove_properties "$new_rmv_pvs" "$option_I_ignore_properties"
      fi
      creation_pvs="$new_rmv_pvs"

      remove_sources "$creation_pvs"
      creation_option_list=$(echo "$new_rmvs_pv" | tr "," "\n" | sed "s/\(.*\)=\(.*\)/\1=\'\2\'/" | tr "\n" "," | sed 's/,$//' | sed -e 's/,/ -o /g')

      if [ "$creation_option_list" != "" ]; then
        creation_option_list=" -o $creation_option_list"
      fi
      if [ "$source_dstype" = "volume" ]; then
        creation_option_list=" -V $source_volsize $creation_option_list"
      fi

      # revert to old field separator
      # (This and reversion back is so that $RZFS command works with -r)
      IFS=$OLDIFS

      echov "Creating destination filesystem \"$actual_dest\" \
with specified properties."
      if [ $option_n_dryrun -eq 0 ]; then
        eval "$RZFS create -p $creation_option_list $actual_dest" ||
          throw_error "Error when creating destination filesystem."
      else
        echo "$RZFS create -p $creation_option_list $actual_dest"
      fi

      #change the field separator to a ","
      OLDIFS=$IFS
      IFS=","
    fi
  else # it does exist, need to create.

    # For the child, we need to do:
    # If the destination list does exist, we need to do the following:
    # 1. Check that the "must create" properties are the same, otherwise exit.
    # 2. Check that all the remaining values and sources are appropriate on the
    #      destination, or are required to be set or inherited.

    # For the initial source, we need to do:
    # If the destination list does exist, we need to do the following:
    # 1. Check that the "must create" properties are the same, otherwise exit.
    # 2. Check that all the remaining values are the same, and that each source
    #      is "local". This applies both to -P properties and -o properties
    # 3. If either of those are different, we need to set them.

    # revert to old field separator
    # (This and reversion back is so that $RZFS command works with -r)
    IFS=$OLDIFS

    dest_pvs=$($RZFS get -Hpo property,value,source all "$actual_dest")
    dest_human_pvs=$($RZFS get -Ho property,value,source all "$actual_dest")

    #change the field separator to a ","
    OLDIFS=$IFS
    IFS=","

    dest_pvs=$(echo "$dest_pvs" | tr -s "\t" "=" | tr -s "\n" ",")
    dest_pvs=${dest_pvs%,}
    dest_human_pvs=${dest_human_pvs%,}
    resolve_human_vars "$dest_pvs" "$dest_human_pvs"
    dest_pvs="$human_results"

    # remove the readonly properties and values as we are not comparing to them
    remove_properties "$dest_pv" "$readonly_properties"
    # Remove the properties the user has asked us to ignore
    if [ -n "$option_I_ignore_properties" ]; then
      remove_properties "$new_rmv_pvs" "$option_I_ignore_properties"
    fi
    dest_pv="$new_rmv_pvs"

    # Test to see if any of the four properties that must be specified at
    # creation time differ from destination to the overrides, if so
    # terminate with an error.

    must_create_properties="casesensitivity,normalization,jailed,utf8only"

    select_mc "$override_pvs" "$must_create_properties"
    mc_override_pvs="$new_mc_pvs"

    select_mc "$dest_pvs" "$must_create_properties"
    mc_dest_pvs="$new_mc_pvs"

    # this for loop tests for a "must create" property that we can't set
    for ov_line in $mc_override_pvs; do
      ov_property=$(echo "$ov_line" | cut -f1 -d=)
      ov_value=$(echo "$ov_line" | cut -f2 -d=)
      for dest_line in $mc_dest_pvs; do
        found_dest=0
        dest_property=$(echo "$dest_line" | cut -f1 -d=)
        dest_value=$(echo "$dest_line" | cut -f2 -d=)
        for mc_property in $must_create_properties; do
          if [ "$mc_property" = "$dest_property" ] && [ "$mc_property" = "$ov_property" ]; then
            if [ "$ov_value" != "$dest_value" ]; then
              echo "Error: The property \"$dest_property\" may only be set"
              echo "       at filesystem creation time. To modify this property"
              echo "       you will need to first destroy target filesystem."
              usage
              beep
              exit 1
            fi
            # we've matched the must create property, remove it.
            must_create_properties=$(echo "$must_create_properties" | tr -s "," "\n")
            must_create_properties=$(echo "$must_create_properties" | grep -v ^"$mc_property"$ | tr -s "\n" ",")
            found_dest=1
            break # break out of the loop, we found what we wanted
          fi
        done
        if [ $found_dest -eq 1 ]; then
          break
        fi
      done
    done

    # At this stage, the "must create" properties are fine.
    # Now we need to compare destination values and sources for each
    # property from the $override_pv list. If the destination's source field
    # is not "local" and the value field from both source and destination
    # do not match, we will need to set the destination property.
    #

    # remove the "must create" properties from the $override_pvs list
    must_create_properties="casesensitivity,normalization,jailed,utf8only"
    remove_properties "$override_pvs" "$must_create_properties"
    override_pvs="$new_rmv_pvs"

    remove_properties "$dest_pvs" "$must_create_properties,$readonly_properties"
    # Remove the properties the user has asked us to ignore
    if [ -n "$option_I_ignore_properties" ]; then
      remove_properties "$new_rmv_pvs" "$option_I_ignore_properties"
    fi

    dest_pvs="$new_rmv_pvs"

    # zfs set takes a long time; let's only set the properties we need to set
    # or inherit the properties we need to inherit

    # changes begin here

    ov_initsrc_set_list="" # for initial source only
    ov_set_list=""         # for child sources
    ov_inherit_list=""     # for child sources
    for ov_line in $override_pvs; do
      ov_property=$(echo "$ov_line" | cut -f1 -d=)
      ov_value=$(echo "$ov_line" | cut -f2 -d=)
      ov_source=$(echo "$ov_line" | cut -f3 -d=)
      for dest_line in $dest_pvs; do
        dest_property=$(echo "$dest_line" | cut -f1 -d=)
        dest_value=$(echo "$dest_line" | cut -f2 -d=)
        dest_source=$(echo "$dest_line" | cut -f3 -d=)
        if [ "$ov_property" = "$dest_property" ]; then
          if [ "$dest_value" != "$ov_value" ] || [ "$dest_source" != "local" ]; then
            ov_initsrc_set_list="$ov_initsrc_set_list$ov_property=$ov_value,"
          fi
          # Now we decide whether to leave, set, or inherit on the destination
          if [ "$ov_value" != "$dest_value" ]; then
            # value needs to be set or inherited, which one?
            if [ "$ov_source" = "local" ]; then
              #value needs to be set
              ov_set_list="$ov_set_list$ov_property=$ov_value,"
            else
              # source is not local and value needs to be force inherited
              ov_inherit_list="$ov_inherit_list$ov_property=$ov_value,"
            fi
          # at this stage, the src and dest values are the same, just need
          # to figure out whether to set or inherit
          elif [ "$ov_source" = "local" ] && [ "$dest_source" != "local" ]; then
            # value needs to be set
            ov_set_list="$ov_set_list$ov_property=$ov_value,"
          elif [ "$ov_source" != "local" ] && [ "$dest_source" = "local" ]; then
            # need to force inherit
            ov_inherit_list="$ov_inherit_list$ov_property=$ov_value,"
          fi
        fi
        # we've matched the dest_line, remove it.
        dest_pvs=$(echo "$dest_pvs" | tr -s "," "\n" | grep -v ^"$dest_line"$)
        dest_pvs=$(echo "$dest_pvs" | tr -s "\n" ",")
        break
      done
    done

    # remove commas from end of line
    ov_initsrc_set_list=${ov_initsrc_set_list%,}
    ov_set_list=${ov_set_list%,}
    ov_inherit_list=${ov_inherit_list%,}

    # Now we have a list of only changes to make using zfs set.
    # Let's make the changes.

    # First notify the user
    if [ "$ov_set_list" != "" ] ||
      [ "$ov_inherit_list" != "" ] ||
      [ "$ov_initsrc_set_list" != "" ]; then
      echov "Setting properties/sources on destination filesystem \"$actual_dest\"."
    fi

    if [ "$initial_source" = "$source" ]; then
      ov_set_list="$ov_initsrc_set_list"
    fi

    # set properties that need setting
    for ov_line in $ov_set_list; do
      ov_property=$(echo "$ov_line" | cut -f1 -d=)
      ov_value=$(echo "$ov_line" | cut -f2 -d=)

      # revert to old field separator
      # (This and reversion back is so that $RZFS command works with -r)
      IFS=$OLDIFS

      if [ $option_n_dryrun -eq 0 ]; then
        $RZFS set "${ov_property}=${ov_value}" "$actual_dest" ||
          trhow_error "Error when setting properties on destination filesystem."
      else
        echo "$RZFS set $ov_property=$ov_value $actual_dest"
      fi

      #change the field separator to a ","
      OLDIFS=$IFS
      IFS=","

    done

    if [ "$initial_source" != "$source" ]; then
      # Now we have a list of only changes to make using zfs inherit.
      # Let's make the changes.
      for ov_line in $ov_inherit_list; do
        ov_property=$(echo "$ov_line" | cut -f1 -d=)
        ov_value=$(echo "$ov_line" | cut -f2 -d=)

        # revert to old field separator
        # (This and reversion back is so that $RZFS command works with -r)
        IFS=$OLDIFS

        if [ $option_n_dryrun -eq 0 ]; then
          $RZFS inherit "$ov_property" "$actual_dest" ||
            throw_error "Error when inheriting properties on destination filesystem."
        else
          echo "$RZFS inherit $ov_property $actual_dest"
        fi

        #change the field separator to a ","
        OLDIFS=$IFS
        IFS=","

      done
    fi
  fi

  # revert to old field separator
  IFS=$OLDIFS
}

###############################################################################
# ZFS MODE FUNCTIONS
###############################################################################

#
# The snapshot size is estimated. The estimate does not take into consideration
# the compression ratio of the data. The estimate is based on the size of the
# dataset. When compression is used, the bar will terminate sooner,
# ending at the compression ratio.
# Takes $LZFS (which may contain the ssh commmand if -O is used)
#
calculate_size_estimate() {
  _snapshot=$1

  _size_dataset=$($LZFS send -nPv "$_snapshot" 2>&1) ||
    throw_error "Error calculating estimate: $_size_dataset"
  _size_est=$(echo "$_size_dataset" | grep ^size | tail -n 1 | cut -f 2)

  echo "$_size_est"
}

setup_progress_dialog() {
  _size_est=$1
  _snapshot=$2

  _progress_dialog=$(echo "$option_D_display_progress_bar" |
    sed "s#%%size%%#$_size_est#g" |
    sed "s#%%title%%#$_snapshot#g")

  echo "$_progress_dialog"
}

#
# 2024.03.08 - generates error when creating a new dataset in target with:
# cannot receive new filesystem stream: incomplete stream
# Error when executing command.
#
handle_progress_bar_option() {
  _snapshot=$1
  _progress_bar_cmd=""

  # Calculate the size estimate and set up the progress dialog
  _size_est=$(calculate_size_estimate "$_snapshot")
  _progress_dialog=$(setup_progress_dialog "$_size_est" "$_snapshot")

  # Modify the send command to include the progress dialog
  _progress_bar_cmd="| dd obs=1048576 | dd bs=1048576 | $_progress_dialog"

  echo "$_progress_bar_cmd"
}

set_send_command() {
  _snapshot=$1
  _prevsnap=$2

  if [ -z "$_prevsnap" ]; then
    echo "$zfs_cmd send $_snapshot"
  else
    echo "$zfs_cmd send -i $_prevsnap $_snapshot"
  fi
}

set_receive_command() {
  _dest=$1
  echo "$zfs_cmd receive $option_F_force_rollback $_dest"
}

wrap_command_with_ssh() {
  _cmd=$1
  _option=$2
  _compress=$3
  _direction=$4

  if [ "$_compress" -eq 0 ]; then
    echo "$ssh_cmd $_option \"$_cmd\""
  else
    if [ "$_direction" = "send" ]; then
      echo "$ssh_cmd $_option \"$_cmd | $compress_cmd\" | $decompress_cmd"
    else
      echo "$compress_cmd | $ssh_cmd $_option \"$decompress_cmd | $_cmd\""
    fi
  fi
}

#
# Handle zfs send/receive
# Takes $option_D_display_progress_bar $option_z_compress, $option_O_origin_user_host, $option_T_target_user_host
#
zfs_send_receive() {
  _snapshot=$1
  _dest=$2
  _prevsnap=$3

  # Set up the send and receive commands
  _send_cmd=$(set_send_command "$_snapshot" "$_prevsnap")
  _recv_cmd=$(set_receive_command "$_dest")

  if [ "$option_O_origin_user_host" != "" ]; then
    _send_cmd=$(wrap_command_with_ssh "$_send_cmd" "$option_O_origin_user_host" $option_z_compress "send")
  fi
  if [ "$option_T_target_user_host" != "" ]; then
    _recv_cmd=$(wrap_command_with_ssh "$_recv_cmd" "$option_T_target_user_host" $option_z_compress "receive")
  fi

  # Perform this after ssh wrapping occurs
  if [ "$option_D_display_progress_bar" != "" ]; then
    _progress_bar_cmd=$(handle_progress_bar_option "$_snapshot")
    _send_cmd="$_send_cmd $_progress_bar_cmd"
  fi

  execute_command "$_send_cmd | $_recv_cmd"
}

# Check if the snapshot already exists
snapshot_exists() {
  _snapshot=$1
  _snapshot_list=$2
  echo "$_snapshot_list" | grep -q "^$_snapshot"
}

#
# Copy a snapshot using zfs send/receive. If a third argument is used, then use
# send -i and the third argument is the base to create the increment from.
# Arguments should be compatible with zfs send and receive commands. Does
# nothing if the snapshot already exists.
# Takes $dest, rzfs_list_ho_s
#
copy_snap() {
  _copysrc=$1
  _copyprev=$2

  _copydest=$dest
  _copysrctail=$(echo "$_copysrc" | cut -d/ -f2-)

  # Check if the snapshot already exists
  if snapshot_exists "$dest/$_copysrctail" "$rzfs_list_ho_s"; then
    echov "Snapshot $_copysrc already exists at destination $_copydest. Exiting function."
    return
  fi

  zfs_send_receive "$_copysrc" "$_copydest" "$_copyprev"
}

#
# Copy the list of snapshots given in stdin to the destination in $1.
# Use incremental snapshots where possible. Assumes that the list of snapshots
# is given in creation order. copy_snap is responsible for skipping already
# existing snapshots on the destination side.
# Takes: $found_last_common_snap, $last_common_snap, $source, $copy_fs_snapshot_list
#
copy_snap_multiple() {
  _lastsnap=""

  # if there is a snapshot common to both src and dest, set that to be $lastsnap
  if [ $found_last_common_snap -eq 1 ]; then
    _lastsnap="$source@$last_common_snap"
  fi

  # XXX: This can get stale, especially if it has taken hours to copy the
  # previous snapshot. Consider adding a time check and refreshing the list of
  # snapshots if it has been too long since we got the list
  for _snapshot in $copy_fs_snapshot_list; do
    copy_snap "$_snapshot" "$_lastsnap"
    _lastsnap=$_snapshot
  done
}

#
# Copy all snapshots of a given filesystem.
# This takes $src_snapshot_transfer_list, $actual_dest.
#
copy_fs() {
  dest=$actual_dest

  # Instead of transferring all the source snapshots, this just transfers
  # the ones starting from the latest common snapshot on src and dest
  copy_fs_snapshot_list=$(echo "$src_snapshot_transfer_list" | grep ".")
  copy_snap_multiple
}

#
# Stop a list of SMF services. The services are read in from stdin.
#
stopsvcs() {
  while read -r service; do
    echov "Disabling service $service."
    svcadm disable -st "$service" ||
      {
        echo "Could not disable service $service."
        relaunch
        exit 1
      }
    torestart="$torestart $service"
  done
}

#
# Relaunch a list of stopped services
#
relaunch() {
  for i in $torestart; do
    echov "Restarting service $i"
    svcadm enable "$i" || {
      echo "Couldn't re-enable service $i."
      exit
    }
  done
}

#
# Create a new recursive snapshot.
#
newsnap() {
  snap=$zxfer_new_snapshot_name

  if [ "$option_R_recursive" != "" ]; then
    echov "Creating recursive snapshot $sourcefs@$snap."
    cmd="$LZFS snapshot -r $sourcefs@$snap"
  else
    echov "Creating snapshot $sourcefs@$snap."
    cmd="$LZFS snapshot $sourcefs@$snap"
  fi

  execute_command "$cmd"
}

#
# Tests to see if they are trying to sync a snapshots; exit if so
#
check_snapshot() {
  _initial_source=$1

  _initial_sourcesnap=$(extract_snapshot_name "$_initial_source")

  # When using -s or -m, we don't want the source to be a snapshot.
  [ -n "$_initial_sourcesnap" ] && throw_error "Snapshots are not allowed as a source."
}

#
# Calculate a list of properties that are not supported on the destination so
# they can be excluded from the properties transfer
# This allows replicating data from newer version of ZFS to older versions
#
calculate_unsupported_properties() {
  # Get a list of the supported properties from the destination
  dest_pool_name=${destination%%/*}
  dest_supported_properties=$($RZFS get -Ho property all "$dest_pool_name")

  # Get a list of the supported properties from the source
  source_pool_name=${initial_source%%/*}
  source_supported_properties=$($LZFS get -Ho property all "$source_pool_name")

  unsupported_properties=

  for s_p in $source_supported_properties; do
    found_supported_prop=0
    for d_p in $dest_supported_properties; do
      if [ "$s_p" = "$d_p" ]; then
        found_supported_prop=1
        break
      fi
    done
    if [ $found_supported_prop -eq 0 ]; then
      unsupported_properties="${unsupported_properties}${s_p},"
    fi
  done
  unsupported_properties=${unsupported_properties%,}
}

#
# Tests a snapshot to see if it is older than the grandfather option allows for.
# Takes $ds, (a destination shapshot)
#
grandfather_test() {
  ds=$1
  snap_date=$($RZFS get -H -o value -p creation "$ds")
  diff_sec=$((current_date - snap_date))
  diff_day=$((diff_sec / 86400))
  if [ $diff_day -ge "$option_g_grandfather_protection" ]; then
    snap_date_english=$($RZFS get -H -o value creation "$ds")
    current_date_english=$(date)
    echo "Error: On the destination there is a snapshot marked for destruction"
    echo "by zxfer that is protected by the use of the \"grandfather"
    echo "protection\" option, -g."
    echo
    echo "You have set grandfather protection at $option_g_grandfather_protection days."
    echo "Snapshot name: $ds"
    echo "Snapshot age : $diff_day days old"
    echo "Snapshot date: $snap_date_english."
    echo "Your current system date: $current_date_english."
    echo
    echo "Either amend/remove option g, fix your system date, or manually"
    echo "destroy the offending snapshot. Also double check that your"
    echo "snapshot management tool isn't erroneously deleting source snapshots."
    echo "Note that for option g to work correctly, you should set it just"
    echo "above a number of days that will preclude \"father\" snapshots from"
    echo "being encountered."
    echo
    usage
    beep
    exit 1
  fi
}

# Function to extract snapshot name
extract_snapshot_name() {
  echo "$1" | grep @ | cut -d@ -f2
}

#
# find the most recent common snapshot (since the lists or sorted in descending
# order by by creation date, the first common snapshot is the most recent common)
#
set_last_common_snapshot() {
  _zfs_source_snaps=$1
  _zfs_dest_snaps=$2

  found_last_common_snap=0

  for _dest_snap in $_zfs_dest_snaps; do
    for _src_snap in $_zfs_source_snaps; do
      if [ "$(extract_snapshot_name "$_dest_snap")" = "$(extract_snapshot_name "$_src_snap")" ]; then
        found_last_common_snap=1
        last_common_snap="$(extract_snapshot_name "$_dest_snap")"
        #echov "Found last common snapshot: $last_common_snap."
        # once found, exit the function
        return
      fi
    done
  done
}

#
# Returns a list of destination snapshots that don't exist in the source.
#
get_dest_snapshots_to_delete() {
  _zfs_source_snaps=$1
  _zfs_dest_snaps=$2

  # Create temporary files
  _original_zfs_dest_snaps=$(mktemp)
  _src_tmp=$(mktemp)
  _dest_tmp=$(mktemp)
  _snaps_to_delete_tmp=$(mktemp)

  # Write the snapshot names to the temporary files
  echo "$_zfs_dest_snaps" >"$_original_zfs_dest_snaps"
  echo "$_zfs_source_snaps" | tr ' ' '\n' | sort | $awk_cmd -F'@' "{print \$2}" >"$_src_tmp"
  echo "$_zfs_dest_snaps" | tr ' ' '\n' | sort | $awk_cmd -F'@' "{print \$2}" >"$_dest_tmp"

  # Use comm to find snapshots in _dest_tmp that don't have a match in _src_tmp
  # write the snapshots to delete to a temporary file for use by grep
  comm -13 "$_src_tmp" "$_dest_tmp" > "$_snaps_to_delete_tmp"

  # Use grep to find the matching lines in _dest_tmp
  _dest_snaps_to_delete=$(grep -F -f "$_snaps_to_delete_tmp" "$_original_zfs_dest_snaps")

  # Clean up temporary files
  rm "$_original_zfs_dest_snaps" "$_src_tmp" "$_dest_tmp" "$_snaps_to_delete_tmp"

  # Print the matching lines
  echo "$_dest_snaps_to_delete"
}

delete_snaps() {
  _zfs_source_snaps=$1
  _zfs_dest_snaps=$2

  #echov "Begin delete_snaps()"

  _snaps_to_delete=$(get_dest_snapshots_to_delete "$_zfs_source_snaps" "$_zfs_dest_snaps")

  # deletes non-common snaps on destination if asked to.
  for _snap_to_delete in $_snaps_to_delete; do
    if [ "$option_g_grandfather_protection" != "" ]; then
      grandfather_test "$_snap_to_delete"
    fi

    #echov "Destroying destination snapshot $_snap_to_delete."
    _cmd="$RZFS destroy $_snap_to_delete"
    # pass 1 to continue command if it fails
    execute_command "$_cmd" 1
  done

  #echov "End delete_snaps()"
}

set_src_snapshot_transfer_list() {
  _zfs_source_snaps=$1

  _found_common=0

  src_snapshot_transfer_list=""

  # This prepares a list of source snapshots to transfer, beginning with
  # the first snapshot after the last common one.
  for test_snap in $_zfs_source_snaps; do
    if [ "$test_snap" != "$source@$last_common_snap" ]; then
      if [ $_found_common = 0 ]; then
        src_snapshot_transfer_list="$test_snap,$src_snapshot_transfer_list"
      fi
    else
      _found_common=1
    fi
  done

  src_snapshot_transfer_list=$(echo "$src_snapshot_transfer_list" | tr -s "," "\n")
}

#
# Caches zfs list commands to cut execution time
#
get_zfs_list() {
  #echov "Begin get_zfs_list()"

  # 0 if not a trailing slash;  regex is one character of any sort followed by
  # zero or more of any character until "/" followed by the end of the
  # string.
  trailing_slash=$(echo "$initial_source" | grep -c '..*/$')

  # Now that we know whether there was a trailing slash on the source, no
  # need to confuse things by keeping it on there. Get rid of it.
  initial_source=${initial_source%/}

  rzfs_list_ho_s=$($RZFS list -t filesystem,volume -Ho name -s creation) ||
    throw_error "Failed to retrieve datasets from the destination" 3

  lzfs_list_hr_s_snap=$($LZFS list -Hr -o name -s creation -t snapshot "$initial_source") ||
    throw_error "Failed to retrieve snapshots from the source" 3

  # Note that for OpenSolaris compatibility, instead of using gtac
  # we will use ...| cat -n | sort -nr | cut -c 8-
  # gtac line
  lzfs_list_hr_S_snap=$(echo "$lzfs_list_hr_s_snap" | cat -n)
  lzfs_list_hr_S_snap=$(echo "$lzfs_list_hr_S_snap" | sort -nr | cut -c 8-)
  rzfs_list_hr_S_snap=$($RZFS list -Hr -o name -S creation -t snapshot "$destination") ||
    throw_error "Failed to retrieve snapshots from the destination" 3

  recursive_source_list=$($LZFS list -t filesystem,volume -Hr -o name "$initial_source") ||
    throw_error "Failed to retrieve list of datasets from the source" 3

  recursive_dest_list=$($RZFS list -t filesystem,volume -Hr -o name "$destination") ||
    throw_error "Failed to retrieve list of datasets from the destination" 3

  # Exit if source not sound
  if [ "$recursive_source_list" = "" ]; then
    throw_usage_error "Source does not exist."
  fi

  #  Exit if destination not sound
  if [ "$recursive_dest_list" = "" ]; then
    throw_usage_error "Destination filesystem does not exist. Create it first."
  fi

  #echov "End get_zfs_list()"
}

#
# main loop that copies the filesystems
#
copy_filesystems() {
  for source in $recursive_source_list; do
    # Split up source into source fs, last component
    sourcefs=$(echo "$source" | cut -d@ -f1)
    # unused variable
    #sourcefslast=$(echo $sourcefs | sed -e "s%.*/%%")

    get_actual_dest

    # If using the -m feature, check if the source is mounted,
    # otherwise there's no point in us doing the remounting.
    if [ $option_m_migrate -eq 1 ]; then
      source_to_migrate_mounted=$($LZFS get -Ho value mounted "$source")
      if [ "$source_to_migrate_mounted" = "yes" ]; then
        echo "The source filesystem is not mounted, why use -m?"
        exit 1
      fi
      mountpoint=$($LZFS get -Ho value mountpoint "$source")
      propsource=$($LZFS get -Ho source mountpoint "$source")
      echov "Mountpoint is: $mountpoint. Source: $propsource."
    fi

    # Inspect the source and destination snapshots so that we are in position to
    # transfer using the latest common snapshot as a base, and transferring the
    # newer snapshots on source, in order.

    # Get the list of source snapshots in descending order by creation date
    _zfs_source_snaps=$(echo "$lzfs_list_hr_S_snap" | grep "^$source@") >/dev/null 2>&1

    # Get the list of destination snapshots in descending order by creation date
    _zfs_dest_snaps=$(echo "$rzfs_list_hr_S_snap" | grep "^$actual_dest@") >/dev/null 2>&1

    # Find the most recent common snapshot on source and destination.
    set_last_common_snapshot "$_zfs_source_snaps" "$_zfs_dest_snaps"

    # Deletes non-common snaps on destination if asked to.
    if [ $option_d_delete_destination_snapshots -eq 1 ]; then
      delete_snaps "$_zfs_source_snaps" "$_zfs_dest_snaps"
    fi

    # Create a list of source snapshots to transfer, beginning with the
    # first snapshot after the last common one.
    set_src_snapshot_transfer_list "$_zfs_source_snaps"

    # Transfer source properties to destination if required.
    # in the function.
    if [ $option_P_transfer_property -eq 1 ] || [ "$option_o_override_property" != "" ]; then
      transfer_properties
    fi

    # Since we'll mostly wrap around zfs send/receive, we'll leave further
    # error-checking to them.

    #
    # We now have a valid source filesystem, volume or snapshot to copy from and an
    # assumed valid destination filesystem to copy to with a possible snapshot name
    # to give to the destination snapshot.
    #
    copy_fs
    #
    # Now we have replicated all existing snapshots.
    #
  done
}

#
# zfs send/receive mode, aka zfs-replicate mode, aka normal mode
#
run_zfs_mode() {
  echov "Running in zfs send/receive mode."

  if [ "$option_R_recursive" != "" ] && [ "$option_N_nonrecursive" != "" ]; then
    throw_usage_error "If using normal mode (i.e. no -S), you must choose either -N to transfer \
a single filesystem or -R to transfer a single filesystem and its children \
recursively, but not both -N and -R at the same time."
  elif [ "$option_R_recursive" != "" ]; then
    initial_source="$option_R_recursive"
  elif [ "$option_N_nonrecursive" != "" ]; then
    initial_source="$option_N_nonrecursive"
  else
    throw_usage_error "You must specify a source with either -N or -R."
  fi

  # Source and destination can't start with "/", but it's an easy mistake to make
  if [ "$(echo "$initial_source" | grep -c '^/')" -eq "1" ] ||
    [ "$(echo "$destination" | grep -c '^/')" -eq "1" ]; then
    throw_usage_error "Source and destination must not begin with \"/\". Note the example."
  fi

  # Checks options to see if appropriate for a source snapshot
  # echov "Checking source snapshot."
  check_snapshot "$initial_source"

  # When using -c you must use -m as well rule. This forces the user
  # To think twice if they really mean to do the migration.
  [ -n "$services" ] && [ $option_m_migrate -eq 0 ] &&
    throw_error "When using -c, -m needs to be specified as well."

  # Caches all the zfs list calls, gets the recursive list, and gives
  # an opportunity to exit if the source is not present
  get_zfs_list

  # If we are restoring properties get the backup properties
  if [ $option_e_restore_property_mode -eq 1 ]; then
    get_backup_properties
  fi

  if [ $option_U_skip_unsupported_properties -eq 1 ]; then
    calculate_unsupported_properties
  fi

  # If recursive option is not selected, then we only iterate once through
  # the initial source as source
  if [ "$option_R_recursive" = "" ]; then
    recursive_source_list=$initial_source
  fi

  # This gets the root filesystem transferred - e.g.
  # the string after the very last "/" e.g. backup/test/zroot -> zroot
  base_fs=${initial_source##*/}
  # This gets everything but the base_fs, so that we can later delete it from
  # $source
  part_of_source_to_delete=${initial_source%"$base_fs"}

  #
  # If using -s, do a new recursive snapshot, then copy all new snapshots too.
  #
  if [ $option_s_make_snapshot -eq 1 ] && [ $option_m_migrate -eq 0 ]; then
    # We snapshot from the base of the initial source
    sourcefs=$(echo "$initial_source" | cut -d@ -f1)
    # Create the new snapshot with a unique name.
    newsnap
    # Because there are new snapshots, need to get_zfs_list again
    get_zfs_list
  fi

  #
  # If migrating, stop the affected services, unmount the source filesystem, do
  # one last snapshot and replicate that, then give the destination file system
  # the mount point of the source one and restart the services.
  # Note that the replication and transfer of the mountpoint property is done
  # by the main loop.
  # The restarting of the services is done after the main loop is finished.
  if [ $option_m_migrate -eq 1 ]; then
    # Check if any services need to be disabled before doing a migration.
    if [ -n "$services" ]; then
      echo "$services" | stopsvcs
    fi

    for source in $recursive_source_list; do
      # unmount the source filesystem before doing the last snapshot.
      echov "Unmounting $source."
      $LZFS unmount "$source" ||
        {
          echo "Couldn't unmount source $source."
          relaunch
          exit 1
        }
    done

    # We snapshot from the base of the initial source
    sourcefs=$(echo "$initial_source" | cut -d@ -f1)

    # Create the last snapshot with a unique name.
    newsnap

    # We include the mountpoint as a property that should be transferred.
    # Note that $option_P_transfer_property is automatically set to 1, to transfer the property.
    readonly_properties=$(echo "$readonly_properties" |
      sed -e 's/,mountpoint//g')

    # Now we must make the script aware of the new snapshots in existence so
    # we can copy them over.
    get_zfs_list
  fi

  if [ "$option_g_grandfather_protection" != "" ]; then
    echov "Checking grandfather status of all snapshots marked for deletion..."
    old_option_d_delete_destination_snapshots=$option_d_delete_destination_snapshots
    option_d_delete_destination_snapshots=0 # turn off delete so that we are only checking snapshots
    for source in $recursive_source_list; do
      get_actual_dest
      inspect_delete_snap
    done
    option_d_delete_destination_snapshots=$old_option_d_delete_destination_snapshots
    echov "Grandfather check passed."
  fi

  copy_filesystems

  if [ $option_m_migrate -eq 1 ]; then
    # Re-launch any stopped services.
    relaunch
  fi
}

###############################################################################
# RSYNC MODE FUNCTIONS
###############################################################################

#
# This destroys snapshots to clear up the remains of a previous
# incomplete transfer. For -S mode only.
#
clean_up() {

  # A list of snapshots to delete
  snap_delete_list=$($LZFS list -Hr -t snapshot -o name | grep "$snapshot_name")
  snap_delete_list=$(echo "$snap_delete_list" | cat -n | sort -nr)
  snap_delete_list=$(echo "$snap_delete_list" | cut -c 8-)

  # delete the snapshots - about 14 seconds max
  for source_snap in $snap_delete_list; do
    $LZFS destroy "$source_snap"
  done
}

#
# Prepares variables for rsync based transfer of properties
# using transfer_properties()
# This takes  $source, $part_of_source_to_delete, $destination, $initial_source
#
prepare_rs_property_transfer() {
  # Prepare the actual destination (actual_dest) for property transfer.
  # A trailing slash means that the root filesystem is transferred straight
  # into the dest fs, no trailing slash means that this fs is created
  # inside the destination.
  # Note that where L is specified, we use trailing slash mode, where
  # L is not specified, we use non-trailing slash mode.
  if [ "$option_L_rsync_levels_deep" = "" ]; then
    # If the original source was backup/test/zroot and we are transferring
    # backup/test/zroot/tmp/foo, $dest_tail is zroot/tmp/foo
    dest_tail=$(echo "$source" | sed -e "s%^$part_of_source_to_delete%%g")
    actual_dest="$destination"/"$dest_tail"
  else
    trailing_slash_dest_tail=$(echo "$source" | sed -e "s%^$initial_source%%g")
    actual_dest="$destination$trailing_slash_dest_tail"
  fi
}

#
# Creates a list of exclude options to pass to rsync, so that empty directories
# on source corresponding to filesystem mountpoints don't cause a delete
# on the destination, and also optionally to exclude fs mountpoints on dest.
# Takes $opt_srs_all_inc_fs, $opt_src_fs_modif
# Outputs $exclude_options, exclude options to be added to other rsync options
#
get_exclude_list() {
  exclude_options=""

  # First, exclude known source-side filesystem mountpoints
  # They will be empty, and if not excluded --del will delete those folders
  # which will hold valid data on the destination
  exclude_dir_list=$(echo "$opt_srs_all_inc_fs" | grep "^$opt_src_fs_modif" |
    grep -v "^$opt_src_fs_modif$")
  exclude_dir_list=$(echo "$exclude_dir_list" | sed -e "s%^$opt_src_fs_modif%%g")

  # Second, by default we exclude filesystem mountpoints on the
  # destination, as they will have their own rsync transfer or be
  # left for an independent restore procedure.
  if [ $option_i_rsync_include_zfs_mountpoints -eq 0 ]; then
    dest_exclude_dir_list=$(echo "$rzfs_list_Ho_mountpoint" | grep "^$rs_dest" | grep -v "^$rs_dest$")
    dest_exclude_dir_list=$(echo "$dest_exclude_dir_list" |
      sed -e "s%^$rs_dest%%g")
    if [ "$rs_dest" = "/" ]; then
      dest_exclude_dir_list=$(echo "$dest_exclude_dir_list" | sed -e 's%^%/%')
    fi
    # now to remove duplicates
    exclude_dir_list="$exclude_dir_list
$dest_exclude_dir_list"
    exclude_dir_list=$(echo "$exclude_dir_list" | sort -u | grep -v "^$")
  fi

  for exd in $exclude_dir_list; do
    exclude_options="--exclude=$exd $exclude_options"
  done

  # Removes space at end
  exclude_options=$(echo "$exclude_options" | sed -e "s% $%%g")
}

#
# Caches zfs list commands to cut execution time, for option -S
#
get_zfs_list_rsync_mode() {
  recursive_dest_list=$($RZFS list -t filesystem,volume -Hr -o name "$destination")

  #  Exit if destination not sound
  if [ "$recursive_dest_list" = "" ]; then
    throw_usage_error "Destination filesystem does not exist. Create it first."
  fi

  OLD_IFS=$IFS
  IFS=","

  source_fs_list=""
  root_fs=""

  # We want to get a list of every ZFS filesystem that holds data that will be
  # transferred. Note that trailing slashes don't seem to matter.
  option_RN="$option_R_recursive,$option_N_nonrecursive"
  option_RN=${option_RN#,}
  option_RN=${option_RN%,}

  if [ "$option_L_rsync_levels_deep" != "" ]; then
    if [ "$option_L_rsync_levels_deep" -lt "1" ]; then
      throw_usage_error "Option L, if specified, should be 1 or greater."
    fi
    inc_option_L_rsync_levels_deep=$(expr $option_L_rsync_levels_deep + 1)
  fi

  for source_RN in $option_RN; do
    source_RN_trailing_slash=$(echo "$source_RN" | grep -c '..*/$')

    if [ "$source_RN_trailing_slash" -eq 1 ]; then
      throw_usage_error "Do not specify trailing slashes in sources. \
\nThere is no meaning in the context of this program and so this has been disabled."
    fi

    temp_fs_list=$($LZFS list -t filesystem,volume -Hr -o name "$source_RN")
    temp_fs_list_comma=$(echo "$temp_fs_list" | tr -s "\n" ",")
    temp_fs_list_comma=${temp_fs_list_comma%,}

    if [ "$option_L_rsync_levels_deep" != "" ]; then
      for fs in $temp_fs_list_comma; do
        # count the "/" in the line, should be equal or greater to option_L_rsync_levels_deep
        slash_no=$(echo "$fs" | $awk_cmd "$0= NF-1" FS=/)
        if [ "$slash_no" -lt "$option_L_rsync_levels_deep" ]; then
          throw_usage_error "If using option L, ensure that all source files and\
directories are contained in filesystems with as many \"/\" as L."
        fi
        old_root_fs=$root_fs
        root_fs=$(echo "$fs" | $awk_cmd '{for (i=1; i <= '$inc_option_L_rsync_levels_deep'; i++) printf("%s%c", $i, (i=='$inc_option_L_rsync_levels_deep')?ORS:OFS)}' FS=/ OFS=/ ORS=)

        if [ "$root_fs" != "$old_root_fs" ] && [ "$old_root_fs" != "" ]; then
          throw_usage_error "No common root filesystem. If using option L, ensure \
that each source file/directory comes from a common filesystem, and that the
the level specified is not after this common filesystem. e.g. if your pool
has been backed up to storage/backups/root_pool then the level you should
specify is \"2\"."
        fi
      done
    fi

    # exit if source is bogus
    if [ "$temp_fs_list" = "" ]; then
      throw_usage_error "Source in -N or -R option does not exist, or is stored \
on a filesystem that is not ZFS."
    fi

    # used printf in order to print the newlines
    source_fs_list=$(printf "%s\n%s" "$temp_fs_list" "$source_fs_list")
  done
  # We will use primarily the root_fs_parent, but got root_fs because
  # we wanted to check that root_fs is unique.
  # This line strips out the last bit, e.g. tank/back/zroot becomes tank/back
  # The regex is a slash, followed by zero or more non-slash characters,
  # until the end of the line.
  # unused variable
  #root_fs_parent=$(echo "$root_fs" | sed -e 's%/[^/]*$%%g')

  # Remove redundant entries and sort properly
  source_fs_list=$(echo "$source_fs_list" | sort -u)
  # unused variable
  #source_fs_list_rev=$(echo "$source_fs_list" | sort -r)

  # Gets the pools for the fs (e.g. in storage/tmp/foo, this would be "storage")
  source_pool_list=$(echo "$source_fs_list" | cut -f1 -d/ | sort -u)
  source_pool_number=$(echo "$source_pool_list" | wc -l | sed -e 's/ //g')
  if [ "$source_pool_number" -ne 1 ]; then
    throw_usage_error "The sources you list are stored on a total of $source_pool_number pools.\
\nAmend your list of sources until there is only one\
 pool relating to them all."
  fi

  # prepares the variables we will end up using later
  if [ "$option_L_rsync_levels_deep" = "" ]; then
    root_fs="$source_pool_list"
    # unused variable
    #root_fs_parent=""
  fi

  # for recursive option
  # unused variable
  #zfs_list_Ho_name=$($LZFS list -t filesystem,volume -H -o name)
  lzfs_list_Ho_mountpoint=$($LZFS list -t filesystem,volume -Ho mountpoint)
  rzfs_list_Ho_mountpoint=$($RZFS list -t filesystem,volume -Ho mountpoint)

  initial_source=$root_fs
  recursive_source_list=$($LZFS list -t filesystem,volume -Hr -o name "$root_fs" |
    grep -v "^$destination")

  IFS="$OLD_IFS"
}

#
# Transfers a source via rsync
# Takes $source_type, where:
# n = non-recursive
# r = recursive
# Takes $opt_source, which is a source directly from the -N or -R option
#
rsync_transfer() {
  # Note that the source is actually in the snapshot. This gets the
  # ZFS filesystem corresponding to the source in the original -R or -N list.
  opt_src_fs=$($LZFS list -t filesystem,volume -H -o name "$opt_source")

  # We need to get all the filesystems at or below the level of the source.
  # This is a bit tricky; if opt_source is /tmp/foo/bar, and the filesystem
  # that contains it is zroot/tmp/foo (and there is also a zroot/tmp/foo/yip,
  # which we don't want, we only should be concerned about zroot/tmp/foo as
  # everything will be contained therein.
  # If OTOH, we want to transfer /tmp/foo, and this maps to zroot/tmp/foo
  # which also has zroot/tmp/foo/yip, then we must transfer everything in
  # every filesystem under this across.
  # To find out whether the directory is a filesystem, look at the mountpoint
  # properties. Note that this approach won't work for legacy mounts, but as
  # long as we aren't trying to recursively transfer "/", we should be fine.

  # is the source (directory) a filesystem?
  is_fs=$(echo "$lzfs_list_Ho_mountpoint" | tr " " "\n" | grep -c "^$opt_source$")

  if [ $source_type = "r" ] && [ "$is_fs" -eq "1" ]; then
    # the directory is a filesystem - need to include all fs under source fs
    opt_srs_all_inc_fs=$($LZFS list -t filesystem,volume -H -o name | grep "^$opt_src_fs")
  else
    opt_srs_all_inc_fs=$opt_src_fs # we will only loop through once
  fi

  for opt_src_fs in $opt_srs_all_inc_fs; do
    if [ $source_type = "r" ] && [ "$is_fs" -eq "1" ]; then
      # We need to get the mountpoints of each sub filesystem
      sub_opt_source=$($LZFS get -H -o value mountpoint "$opt_src_fs")
    else
      sub_opt_source=$opt_source
    fi

    # the mountpoint of the above
    opt_src_fs_mountpoint=$($LZFS get -Ho value mountpoint "$opt_src_fs")

    if [ "$opt_src_fs_mountpoint" = "legacy" ]; then
      if [ $option_l_rsync_legacy_mountpoint -eq 0 ]; then
        throw_usage_error "Legacy mountpoint encountered. Enable -l to assume \
that the legacy mountpoint is \"/\"."
      fi

      opt_src_fs_mountpoint="/"
      opt_src_tail=$opt_source
      rs_source="$opt_src_fs_mountpoint.zfs/snapshot/$snapshot_name/.$opt_src_tail"
    else
      # the part of the original source less the mountpoint part
      opt_src_tail=$(echo "$sub_opt_source" |
        sed -e "s%^$opt_src_fs_mountpoint%%g")

      # This is the source (from the atomic snapshot), nearly suitable for
      # rsync usage. What it is will depend on whether it is filesystem
      # or directory.
      rs_source="$opt_src_fs_mountpoint/.zfs/snapshot/$snapshot_name/.$opt_src_tail"
    fi

    # We can think of using L option as restoring, and without L option as
    # backing up. When we back up we copy the root filesystem and everything
    # in it into the destination. (e.g. zroot, zroot/tmp etc. goes into
    # storage/backups/zroot, storage/backups/zroot/tmp etc.) In the case of
    # restoring, we are going the other way around, but it is as if we are
    # coping the original root filesystem directly into the destination (which
    # may be a pool) otherwise we would not be able to restore a pool.

    opt_src_fs_modif=$opt_src_fs
    # This will impact the source and destination that we feed to rsync.
    if [ "$option_L_rsync_levels_deep" != "" ]; then
      # This will trim ($option_L_rsync_levels_deep + 1) folders off the beginning of the fs, e.g.
      # "tank/foo/bar/zroot/tmp/yum" becomes (with option_L_rsync_levels_deep = 3) "tmp/yum"
      inc_option_L_rsync_levels_deep=$(expr $option_L_rsync_levels_deep + 1)

      n=1
      while [ ${n} -le ${inc_option_L_rsync_levels_deep} ]; do
        opt_src_fs_modif=$(echo "$opt_src_fs_modif" | sed -e 's%^[^/]*%%' | sed -e 's%^/%%')
        n=$((n + 1))
      done
    fi
    #rs_dest="/$destination/$opt_src_fs_modif$opt_src_tail"
    rs_dest="/$destination/$opt_src_fs_modif"

    # if $destination is "zroot/foo/bar", this regex gets "zroot"
    dest_root=$(echo "$destination" | sed -e 's%/.*$%%')

    dest_root_mountpoint=$($RZFS get -Ho value mountpoint "$dest_root")
    if [ "$dest_root_mountpoint" = "legacy" ]; then
      if [ $option_l_rsync_legacy_mountpoint -eq 0 ]; then
        throw_usage_error "Legacy mountpoint encountered. Enable -l to assume \
that the legacy mountpoint is \"/\"."
      fi
      rs_dest=$(echo "$rs_dest" | sed -e "s%^/[^/]*%%g")
    fi

    full_rs_options="$rsync_options"

    get_exclude_list

    if [ "$source_type" = "r" ]; then
      # Appends a slash and the "-r" option, to suit rsync
      rs_source="$rs_source/"
      full_rs_options="$full_rs_options $exclude_options -r"
      if [ $option_d_delete_destination_snapshots -eq 1 ]; then
        full_rs_options="$full_rs_options --del"
      fi
    elif [ -d "$rs_source" ]; then
      # Appends a slash and the "-d" option if a directory, to suit rsync
      # if a directory
      rs_source="$rs_source/"
      full_rs_options="$full_rs_options -d"
      if [ $option_d_delete_destination_snapshots -eq 1 ]; then
        full_rs_options="$full_rs_options --del"
      fi
    else
      : # is a file; note that ":" is a dummy command.
    fi

    if [ "$option_E_rsync_exclude_patterns" != "" ]; then # add user-specified exclude patterns.
      option_E_rsync_exclude_patterns=$(echo "$option_E_rsync_exclude_patterns" | sed -e "s% $%%g")
      full_rs_options="$full_rs_options $option_E_rsync_exclude_patterns"
    fi

    echov "Using rsync to recursively transfer $rs_source to $rs_dest with \
options $full_rs_options"

    # Now that we have something to feed rsync, we will call it.
    if [ $option_n_dryrun -eq 0 ]; then
      if [ $option_p_rsync_persist -eq 1 ]; then
        $rsync_cmd "$full_rs_options" "$rs_source" "$rs_dest" # persist in face of error
      else
        $rsync_cmd "$full_rs_options" "$rs_source" "$rs_dest" ||
          throw_error "Error when executing rsync."
      fi
    else
      echo "$rsync_cmd $full_rs_options $rs_source $rs_dest"
    fi

  done # End of sub-filesystem loop
}

#
# rsync mode
#
# From here, the basic algorithm is:
# 1. Delete anything that could have been left over from previous transfers.
# This could include: snapshots of original fs.
# 2. Get the pools relating to any filesystem relating to any directories that
#     will be transferred.
# 3. Take a recursive snapshot of each of those pools.
# 4. Create the destination filesystems or set appropriately. (If elected to
#     restore the properties, restore them from the backup file or fail. If
#     elected to backup the properties, back them up to the file
#     .zxfer_backup_info.$poolname at the filesystem
#     that $poolname will sit in.)
#  (see transfer_properties() )
# 5. Ensure that if any property is readonly, it is set to writable before transfer.
# 6. rsync the directories and files across, using the snapshots.
# 7. Set any previously readonly destination filesystems to be writable.
# 9. Delete the remnants, probably very similar process to 1.

# optimization summary: recursive snapshots take 8 seconds - unavoidable.
#                     : cloning filesystems takes a long time, clone as few as possible
#                     : deleting clones takes even longer, clone as few as possible

# Note that using clones was far easier to implement the rsync version of the script.
# We have however opted to use just snapshots as the time taken to create and delete
# clones is prohibitive in comparison. It also stops automatic snapshotting taking
# snapshots of the clones and creating further havoc.
#
run_rsync_mode() {
  # destroys old snapshots used in any previous (incomplete) use of
  # the script's functionality, if not using a custom snapshot
  if [ $option_u_rsync_use_existing_snapshot -eq 0 ]; then
    clean_up
  fi

  get_zfs_list_rsync_mode

  # If we are restoring properties get the backup properties
  if [ $option_e_restore_property_mode -eq 1 ]; then
    get_backup_properties
  fi

  # get the correct options to feed to rsync (excluding recursive)
  rsync_options="$default_rsync_options"
  if [ "$option_f_rsync_file_options" != "" ]; then
    # gets the options to be passed to rsync, if able to be read.
    if [ -r "$option_f_rsync_file_options" ]; then
      rsync_options=$(cat "$option_f_rsync_file_options")
    else
      throw_usage_error "Reading contents of $option_f_rsync_file_options."
    fi
  fi

  # recursively snapshot the source (if not using custom snapshot)
  if [ $option_u_rsync_use_existing_snapshot -eq 0 ]; then
    $LZFS snapshot -r "${initial_source}@${snapshot_name}"
  fi

  # for the first iteration of property transfer, we need to override the
  # readonly property of the filesystem so that rsync will work.
  ensure_writable=1

  # make sure override list includes "readonly=off"
  old_option_o_override_property=$option_o_override_property
  option_o_override_property=$(echo "$option_o_override_property" | sed -e 's/readonly=on/readonly=off/g')
  ro_exist=$(echo "$option_o_override_property" | grep -c "readonly")
  if [ "$ro_exist" -eq 0 ]; then
    if [ "$option_o_override_property" = "" ]; then
      option_o_override_property="readonly=off"
    else
      option_o_override_property="$option_o_override_property,readonly=off"
    fi
  fi

  # we don't want to write the backup info this time, as it will be done later
  dont_write_backup=1

  # Transfer source properties to destination if required, or create the fs.
  if [ $option_P_transfer_property -eq 1 ] || [ "$option_o_override_property" != "" ]; then
    # loop that sets the filesystem properties
    for source in $recursive_source_list; do
      # prepares some variables for property_transfer
      prepare_rs_property_transfer

      # Needs: $source, $initial_source, $actual_dest, $recursive_dest_list
      transfer_properties
    done
  fi

  # NOW, create the loop that will transfer each source file/directory across.
  # Need one loop for recursive, one loop for non-recursive
  option_N_nonrecursive_space=$(echo "$option_N_nonrecursive" | tr "," "\n")
  option_R_recursive_space=$(echo "$option_R_recursive" | tr "," "\n")

  # Loop for the non-recursive
  for opt_source in $option_N_nonrecursive_space; do
    source_type="n"
    rsync_transfer
  done

  # Loop for the recursive directories
  for opt_source in $option_R_recursive_space; do

    # We want to ensure that the source is a directory, and to fail if not
    if [ -d "$opt_source" ]; then
      : # if a directory, do nothing
    else
      # if not a directory, fail with error
      throw_usage_error "Only directories are allowed when using recursive \
rsync transfer mode (i.e. -R). If you are trying to transfer \
a single file, use -N."
    fi

    source_type="r"
    rsync_transfer
  done # End of recursive directory loop

  # reset backup file contents as they are built up in transfer_properties
  backup_file_contents=""

  # Now the readonly property will be as it is supposed to be when
  # properties are transferred.

  # this time we want to write the backup
  dont_write_backup=0

  # this time the properties should be as intended on dest.
  ensure_writable=0

  # clean up option_o_override_property to remove readonly=off
  option_o_override_property=$old_option_o_override_property

  # get new lists as there may be new filesystems now
  get_zfs_list_rsync_mode

  # Transfer source properties to destination if required.
  if [ $option_P_transfer_property -eq 1 ] || [ "$option_o_override_property" != "" ]; then
    # loop that sets the filesystem properties
    for source in $recursive_source_list; do

      prepare_rs_property_transfer

      # Needs: $source, $initial_source, $actual_dest, $recursive_dest_list
      transfer_properties
    done
  fi

  # We clean up snapshots if we aren't using a custom snapshot
  if [ $option_u_rsync_use_existing_snapshot -eq 0 ]; then
    clean_up
  fi
}

###############################################################################
# MAIN
###############################################################################
init_globals

read_command_line_switches "$@"

# Read out source and dest values
shift "$((OPTIND - 1))"
destination=$1

# Basic consistency checking
if [ $# -lt 1 ]; then
  throw_usage_error "Need a destination."
fi

init_variables

consistency_check

if [ $option_S_rsync_mode -eq 1 ]; then
  run_rsync_mode
else
  run_zfs_mode
fi

# writes property backup info to file
if [ $option_k_backup_property_mode -eq 1 ]; then
  write_backup_properties
fi

beep 0
exit 0
